
/-
Copyright (c) 2024 Devon Tuma. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Devon Tuma, Quang Dao
-/

import ToMathlib.Control.Monad.Hom
import Mathlib.Data.PFunctor.Univariate.Basic
import Mathlib.Data.ENat.Lattice

/-!
# Free Monads

This file defines the free monad on an _arbitrary_ mapping `f : Type u → Type v`. This has the
undesirable property of raising the universe level by 1, which means we can't pass a `FreeMonad f`
object as a continuation into an interactive protocol.

See `PFunctor.FreeM` for the free monad of a polynomial functor, which does not raise the universe
level.
-/

universe u v w

/-- The free monad on a functor `f` is the type freely generated by values of type `f α`
and the operations `pure` and `bind`. Implemented directly rather than as a quotient.
Slightly different than constructions of free monads in Haskell because of universe issues. -/
inductive FreeMonad (f : Type u → Type v) (α : Type w) : Type (max (u + 1) v w)
  | protected pure (x : α) : FreeMonad f α
  | roll {β : Type u} (x : f β) (r : β → FreeMonad f α) : FreeMonad f α

namespace FreeMonad

variable {f : Type u → Type v} {α β γ : Type u}

/-- Lift an element of the base functor to the free monad by directly returning the result. -/
@[always_inline, inline]
def lift (x : f α) : FreeMonad f α := FreeMonad.roll x FreeMonad.pure

instance : MonadLift f (FreeMonad f) where
  monadLift x := FreeMonad.lift x

@[simp]
lemma monadLift_eq_lift (x : f α) :
  (x : FreeMonad f α) = FreeMonad.lift x := rfl

instance [Inhabited (f α)] : Inhabited (FreeMonad f α) := ⟨FreeMonad.lift default⟩

/-- Bind operator on `OracleComp spec` operation used in the monad definition. -/
@[always_inline, inline]
protected def bind : FreeMonad f α → (α → FreeMonad f β) → FreeMonad f β
  | FreeMonad.pure x, g => g x
  | FreeMonad.roll x r, g => FreeMonad.roll x (λ u ↦ FreeMonad.bind (r u) g)

@[simp]
lemma bind_pure (x : α) (r : α → FreeMonad f β) :
    FreeMonad.bind (FreeMonad.pure x) r = r x := rfl

@[simp]
lemma bind_roll (x : f α) (r : α → FreeMonad f β) (g : β → FreeMonad f γ) :
    FreeMonad.bind (FreeMonad.roll x r) g = FreeMonad.roll x (λ u ↦ FreeMonad.bind (r u) g) := rfl

@[simp]
lemma bind_lift (x : f α) (r : α → FreeMonad f β) :
    FreeMonad.bind (FreeMonad.lift x) r = FreeMonad.roll x r := rfl

instance : Monad (FreeMonad f) where
  pure := FreeMonad.pure
  bind := FreeMonad.bind

@[simp]
lemma monad_pure_def (x : α) : (pure x : FreeMonad f α) = FreeMonad.pure x := rfl

@[simp]
lemma monad_bind_def (x : FreeMonad f α) (g : α → FreeMonad f β) :
    x >>= g = FreeMonad.bind x g := rfl

instance : LawfulMonad (FreeMonad f) :=
  LawfulMonad.mk' (FreeMonad f)
    (λ x ↦ by
      induction' x with α x g r hr
      · rfl
      · exact congr_arg (FreeMonad.roll g) (funext λ u ↦ hr u))
    (λ x f ↦ rfl)
    (λ x f g ↦ by
      induction' x with α x g r hr
      · rfl
      · exact congr_arg (FreeMonad.roll g) (funext λ u ↦ hr u))

instance : MonadFunctor f (FreeMonad f) where
  monadMap g
    | FreeMonad.pure x => FreeMonad.pure x
    | FreeMonad.roll x r => g x >>= r

/-- Proving something about `FreeMonad f α` only requires two cases:
* `pure x` for some `x : α`
Note that we can't use `Sort v` instead of `Prop` due to universe levels.-/
@[elab_as_elim]
protected def inductionOn {C : FreeMonad f α → Prop}
    (pure : ∀ x, C (pure x))
    (roll : ∀ {β} (x : f β), (r : β → FreeMonad f α) →
      (∀ y, C (r y)) → C (x >>= r)) :
    (oa : FreeMonad f α) → C oa
  | FreeMonad.pure x => pure x
  | FreeMonad.roll x r => roll x _ (λ u ↦
      FreeMonad.inductionOn pure roll (r u))

section construct

/-- Shoulde be possible to unify with the above-/
@[elab_as_elim]
protected def construct {C : FreeMonad f α → Type*}
    (pure : (x : α) → C (pure x))
    (roll : {β : Type u} → (x : f β) → (r : β → FreeMonad f α) →
      ((y : β) → C (r y)) → C (x >>= r)) :
    (oa : FreeMonad f α) → C oa
  | .pure x => pure x
  | .roll x r => roll x _ (λ u ↦ FreeMonad.construct pure roll (r u))

variable {C : FreeMonad f α → Type*} (h_pure : (x : α) → C (pure x))
  (h_roll : {β : Type u} → (x : f β) → (r : β → FreeMonad f α) →
    ((y : β) → C (r y)) → C (x >>= r))

@[simp]
lemma construct_pure (y : α) : FreeMonad.construct h_pure h_roll (pure y) = h_pure y := rfl

@[simp]
lemma construct_roll (x : f β) (r : β → FreeMonad f α) :
    (FreeMonad.construct h_pure h_roll (roll x r) : C (roll x r)) =
      (h_roll x r (λ u ↦ FreeMonad.construct h_pure h_roll (r u))) := rfl

end construct

section mapM

variable {m : Type u → Type w} (s : {α : Type u} → f α → m α)

protected def mapM_aux [Pure m] [Bind m] (s : {α : Type u} → f α → m α) :
    (oa : FreeMonad f α) → m α
  | .pure x => pure x
  | .roll x r => s x >>= λ u ↦ (r u).mapM_aux s

protected def mapM' (m : Type u → Type w) [Monad m] [LawfulMonad m]
    (s : {α : Type u} → f α → m α) : FreeMonad f →ᵐ m where
  toFun := FreeMonad.mapM_aux s
  toFun_pure' x := rfl
  toFun_bind' x y := by
    induction x using FreeMonad.inductionOn with
    | pure x => simp [FreeMonad.mapM_aux]
    | roll x r h => simp at h; simp [FreeMonad.mapM_aux, h]

@[simp]
lemma mapM'_lift [Monad m] [LawfulMonad m]
    (s : {α : Type u} → f α → m α) (x : f α) :
    FreeMonad.mapM' m s (FreeMonad.lift x) = s x := by
  simp [FreeMonad.mapM', FreeMonad.lift, FreeMonad.mapM_aux]

/-- Canonical mapping of a free monad into any other monad, given a map on the base functor, -/
protected def mapM [Pure m] [Bind m] :
    (oa : FreeMonad f α) → (s : {α : Type u} → f α → m α) → m α
  | .pure x, _ => pure x
  | .roll x r, s => s x >>= λ u ↦ (r u).mapM s

variable [Monad m]

@[simp]
lemma mapM_pure (x : α) : (FreeMonad.pure x : FreeMonad f α).mapM s = pure x := rfl

-- @[simp]
-- lemma mapM'_pure (x : α) : (FreeMonad.pure x : FreeMonad f α).mapM' s = pure x := rfl

@[simp]
lemma mapM_roll (x : f α) (r : α → FreeMonad f β) :
    (FreeMonad.roll x r).mapM s = s x >>= λ u ↦ (r u).mapM s := rfl

end mapM

-- instance instMonadAlgebra {f} {pre : {α : Type v} → f α → α} : MonadAlgebra (FreeMonad f) where
--   monadAlg
--   | FreeMonad.pure x => x
--   | FreeMonad.roll x r => @instMonadAlgebra.monadAlg _ (r (pre x))

-- def prePostFree {f} {α β} (pre : α → Prop) (post : α × β → Prop) : FreeMonad f Prop → Prop
--   | FreeMonad.pure x => x
--   | FreeMonad.roll x r => ∃ inp, pre inp ∧ ∀ out, post (inp, out) → prePostFree pre post (r out)

section depth

/-- The depth of a free monad as a potentially infinite natural number, defined recursively as the
  maximum depth of its children. -/
noncomputable def depth : FreeMonad f α → ℕ∞
  | .pure _ => 0
  | .roll _ r => 1 + iSup (λ u ↦ depth (r u))

@[simp]
lemma depth_pure {x : α} : depth (pure x : FreeMonad f α) = 0 := rfl

@[simp]
lemma depth_pure' {x : α} : depth (FreeMonad.pure x : FreeMonad f α) = 0 := rfl

@[simp]
lemma depth_roll {x : f α} {r : α → FreeMonad f β} :
    depth (roll x r : FreeMonad f β) = 1 + iSup (λ u ↦ depth (r u)) := rfl

@[simp]
noncomputable def depthBindAux {f : Type u → Type v} {α β : Type u} :
    FreeMonad f α → (α → FreeMonad f β) → ℕ∞
  | .pure x, g => depth (g x)
  | .roll _ r, g => 1 + iSup (λ u ↦ depthBindAux (r u) g)

/-- The depth of a bind computation can be defined _exactly_ using the definition of bind (but might not be very revealing) -/
lemma depth_bind_eq {x : FreeMonad f α} {g : α → FreeMonad f β} :
    depth (x >>= g) = depthBindAux x g := by
  induction x using FreeMonad.inductionOn with
  | pure x => simp [depthBindAux]
  | roll x r hr => simp_all [depthBindAux, FreeMonad.monad_bind_def]

lemma depth_bind_le {x : FreeMonad f α} {g : α → FreeMonad f β} :
    depth (x >>= g) ≤ depth x + iSup (λ u ↦ depth (g u)) := by
  induction x using FreeMonad.inductionOn with
  | pure x => simp; exact le_iSup_iff.mpr fun b a ↦ a x
  | roll x r hr =>
    simp_all
    calc
      _ ≤ 1 + ⨆ u, (r u).depth + ⨆ v, (g v).depth := by
        gcongr; exact hr _
      _ ≤ 1 + (⨆ u, (r u).depth) + ⨆ v, (g v).depth := by
        rw [add_assoc]
        gcongr; simp; intro b; gcongr; exact le_iSup_iff.mpr fun b_1 a ↦ a b

lemma depth_eq_zero_iff {x : FreeMonad f α} : depth x = 0 ↔ ∃ y, x = pure y := by
  induction x using FreeMonad.inductionOn with
  | pure y => simp
  | roll x r hr => simp [hr]

lemma depth_eq_one_iff {x : FreeMonad f α} : depth x = 1 ↔
    (∃ (β : Type u) (y : f β) (r : β → FreeMonad f α), x = roll y r ∧ ∀ u, depth (r u) = 0) := by
  induction x using FreeMonad.inductionOn with
  | pure x' => simp
  | roll y r _hr =>
    rename_i β
    simp
    constructor <;> intro h
    -- Why is this so painful?
    · have hNeTop : ⨆ u, (r u).depth ≠ ⊤ := by
        have : ⨆ u, (r u).depth ≤ 1 := le_of_add_le_right (le_of_eq h)
        exact ne_top_of_le_ne_top (by simp) this
      have : (1 + ⨆ u, (r u).depth).toNat = 1 := by exact
        (ENat.toNat_eq_iff_eq_coe (1 + ⨆ u, (r u).depth) 1).mpr h
      rw [ENat.toNat_add (by simp) hNeTop] at this
      simp [hNeTop] at this
      refine ⟨β, y, r, ⟨⟨rfl, by simp, by simp⟩, this⟩⟩
    · obtain ⟨β', y_1, r_1, ⟨⟨hβ, hy, hr⟩, hr'⟩⟩ := h
      subst hβ hy hr
      simp [hr']

end depth

end FreeMonad
